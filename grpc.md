\## Protobufprotocol buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小、更快、更为简单。有性能高、跨语言、开发容易维护等特点，而且天然集成gRPC框架，因此，Protobuf是微服务中的基石。Protobuf序列化和反序列化，json化的方式在文档：[网络编程]([https://www.xiaoyeshiyu.com/2022/08/11/Golang%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/)](https://www.xiaoyeshiyu.com/2022/08/11/Golang网络编程/))和[RPC](https://www.xiaoyeshiyu.com/2022/07/05/RPC/)中，这里不再赘叙。示例：```protobuf// The greeting service definition.service Greeter {  // Sends a greeting  rpc SayHello (HelloRequest) returns (HelloReply) {}}// The request message containing the user's name.message HelloRequest {  string name = 1;}// The response message containing the greetingsmessage HelloReply {  string message = 1;}```### 语法Protobuf文件一般以`.proto`结尾```protobuf syntax = "proto3"; // 表明版本是proto3，需要放在最开头  option go_package = "920/minegrpc;minegrpc"; // 代表生成的go代码，包目录是920/minegrpc，包名称是minegrpc```定义数据结构```protobufmessage HelloRequest {    string name = 1;	// 1 代表字段编号}```下载工具```shell$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2```目录树```minegrpc└── helloworld    └── helloworld.proto```生成stub代码```shell$ cd minegrpc && protoc --go_out=. --go_opt=paths=source_relative \    --go-grpc_out=. --go-grpc_opt=paths=source_relative \    helloworld/helloworld.proto````--go_out=.`：代表将**数据结构**go代码生成到当前目录`--go-grpc_out=.`：代表将**stub**go代码生成到当前目录`paths=source_relative`：会使文件中`option go_package = "920/grpc;grpc";`定义失效，会生成到`helloworld`目录下生成代码如下：```minegrpc└── helloworld    ├── helloworld.pb.go    ├── helloworld.proto    └── helloworld_grpc.pb.go```如果要生成到`minegrpc`目录下，可以通过`--proto_path`指定目录，设置当前目录为`grpc`目录(或者 `-I` 指定目录)```shell$ protoc --proto_path=./helloworld \        --go_out=. --go_opt=paths=source_relative \    --go-grpc_out=. --go-grpc_opt=paths=source_relative \    helloworld.proto```结果```minegrpc├── helloworld│  └── helloworld.proto├── helloworld.pb.go						// 生成结构体对象└── helloworld_grpc.pb.go				// 生成对象方法```引用包中的结构体和方法是，则是通过```goimport minegrpc "gostudy/920/minegrpc"```生成的结构体，可以看到注释也一起生成```go// The request message containing the user's name.type HelloRequest struct {	state         protoimpl.MessageState	sizeCache     protoimpl.SizeCache	unknownFields protoimpl.UnknownFields	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"` // 1 代表字段编号}```生成的服务端方法，在`helloworld_grpc.pb.go`中```gotype GreeterServer interface {	// Sends a greeting	SayHello(context.Context, *HelloRequest) (*HelloReply, error)	// Sends another greeting	SayHelloAgain(context.Context, *HelloRequest) (*HelloReply, error)	mustEmbedUnimplementedGreeterServer()}```客户端方法也在`helloworld_grpc.pb.go`中```gotype GreeterClient interface {	// Sends a greeting	SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)	// Sends another greeting	SayHelloAgain(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)}func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient {	return &greeterClient{cc}}```### 数据类型protoco buffer中的数据类型对照：[proto3](https://developers.google.com/protocol-buffers/docs/proto3)，中文：[高效的数据压缩编码方式 Protobuf](https://halfrost.com/protobuf_encode/#toc-0)%3Cimg src="https://raw.githubusercontent.com/xiaoyeshiyu/image-hosting-service/main/uPic/2022/09/image-20220922210413261.png" alt="image-20220922210413261" style="zoom:50%;" />默认值：当一个消息被解析时，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置为一个默认值，不同类型默认值如下：* string，默认是一个空的string* bytes，默认是一个空的bytes* bools，默认是false* 数值类型，默认是0* 枚举类型，默认是第一个枚举值，也就是0* 消息体，在go里面是nil，而不是为空* 重复型，空slice默认值在不同的语言中可能不同，具体的默认值可以查看文档：[generated code guide](https://developers.google.com/protocol-buffers/docs/reference/overview)例如枚举类型```protobufenum Goods {	// 枚举类型，在Golang中生成是int32类型    GOODS_UNSPECIFIED = 0;		// 注意，枚举类型的第一个字段，一定是0    GOODS_APPLE = 1;    GOODS_BANANA = 2;